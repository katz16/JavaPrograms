Design patterns are typically categorized into three main types:

Creational Patterns: These patterns deal with object creation mechanisms, aiming to increase flexibility and reuse of existing code.

    Singleton: Ensures a class has only one instance and provides a global access point to it.
                During the application's lifecycle, only one object of a class is created.
             Benefits:
                Resource Saving: Reduces memory usage by preventing multiple instances.
                Global Access: The single instance of the class can be accessed across all parts of the application.
             Disadvantages:
                Tight Coupling: Can lead to tight coupling between the singleton class and its clients.
                Testing Challenges: Makes unit testing difficult due to the global state.

    Factory Method: Provides an interface for creating objects in a superclass, allowing subclasses to decide which class to instantiate.

    Abstract Factory: Allows the creation of families of related objects without specifying their concrete classes.

    Builder: Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.

    Prototype: Allows copying existing objects without making the code dependent on their classes.

Structural Patterns: These patterns focus on the composition of classes and objects to form larger structures, simplifying the design by identifying relationships between them.

    Adapter: Allows objects with incompatible interfaces to collaborate.

    Bridge: Decouples an abstraction from its implementation, allowing them to vary independently.

    Composite: Composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions uniformly.

    Decorator: Attaches new responsibilities to an object dynamically.

    Facade: Provides a simplified interface to a complex subsystem.

    Proxy: Provides a surrogate or placeholder for another object to control access to it.

Behavioral Patterns: These patterns are concerned with the responsibilities and interactions between objects, ensuring loose coupling and effective communication.

    Observer: Defines a one-to-many dependency between objects, where changes in one object automatically notify and update all its dependents.

    Strategy: Defines a family of algorithms, encapsulates each one, and makes them interchangeable.

    Command: Encapsulates a request as an object, allowing parameterization of clients with different requests, queuing or logging requests, and supporting undoable operations.

    Iterator: Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

    Mediator: Defines an object that encapsulates how a set of objects interact, promoting loose coupling.

    State: Allows an object to alter its behavior when its internal state changes, appearing to change its class.

    Template Method: Defines the skeleton of an algorithm in an operation, deferring some steps to subclasses.

    Chain of Responsibility: Avoids coupling the sender of a request to its receiver by giving multiple objects a chance to handle the request.

    Interpreter: Given a language, defines a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.

    Memento: Captures and externalizes an object's internal state without violating encapsulation, so that the object can be restored to this state later.

    Visitor: Represents an operation to be performed on the elements of an object structure, allowing new operations to be defined without changing the classes of the elements on which they operate.